\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\def\jss#1{{\footnotesize [{\bf jss:} #1]}}

\title{Boolean Operations}
\author{Shengtan Mao, Jack Snoeyink}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
We detail an implementation of regularized Boolean operations (union, intersection, difference) for two polygonal regions in the plane that directly produces a triangulation of the output region. 
It is based on an optimal red/blue segment intersection algorithm that requires only double the input precision.  
We carefully define predicates so that we do not need to define shared endpoints or overlapping segments as degeneracies requiring special handling, but can fold them into the general case.  
Output can be produced in compact forms.  
We do not address the geometric rounding of intersection points (which may require more than double precision) back to input precision, since such rounding must be application-specific.
\end{abstract}
\section{Introduction}

%% Set context
The Boolean operations of intersection, union, and difference for polygonal regions in the plane are fundamental to applications such as Geographic Information Systems (GIS)
and Computer Aided Design (CAD).  
In these applications the input is one or more collections of straight line segments that bound a region of the plane.
Each segment is labeled with which side is the region interior; our algorithm will detect if the labels are inconsistent.
The desired output may be the union, intersection, difference or symmetric difference of regions. 

We assume that the input region is regularized -- that it equals the closure of its interior, 
$A= \textit{cl}(\textit{int}(A))$. , and produce regularized output. 
Regularization removes low dimensional features, allowing us to define boundary cycles: 
We define a region's \textit{boundary} to be the nested set of cycles of segments that share a vertex, forming an angle that is locally entirely inside one region.
Note that this definition is asymmetric in its handling of the interior and exterior of a region:  Two triangles that touch at a single vertex are considered as two separate cycles if the interior is inside, and as a single cycle if the interior is outside.  

Input precision

Boolean operations

Sweep algorithms in the plane convert two-dimensional problems into dynamic one-dimensional problems,
often by sweeping a line or pseudoline across segments in the
plane and observing events where the order of segments crossing the sweep changes.
In such a sweep,  the events will obviously be segment endpoints and intersections. Like many obvious things in mathematics it takes careful definition to make this precise -- especially when many segments can end at a common endpoint, but we want to process them one at a time to keep the handling simple, and when we want to process bundles of segments the cross as a grid for efficiency.  
Therefore, we begin with several definitions and invariants before we identify the events and say how to handle them. 

\section{Definitions}
Points in the plane are compared by lexicographic order, breaking ties in $x$ coordinates by comparing $y$ coordinates.

\subsection{Segments, Flags, Intersections}
A \textit{segment} consists of two endpoints $p<q$, a color (red or blue), and
a label whether the region it bounds is above or below. 
%pic
We assume that segment endpoints are represented exactly in {\it input precision}.
If the relative interior of any segment $pr$ contains a segment endpoint $q$, 
then we break $pr$ into $pq$ and $qr$. We cannot break at all intersection points, 
because those may require greater than input precision. 

Because segments can share endpoints, it is useful to introduce \textit{flags}: 
segment $pq$ has a \textit{start} flag at $p$ and \textit{terminal} flag at $q$, 
which inherit the color, slope, and label from $pq$. 
\jss{probably need notation for the flags of $pq$: could even use $p_q$ for start and $_pq$ for terminal.}
%identifying flags in words may be clearer since the flag point could be an intersection
To compare flags, we compare the points, breaking ties so terminal flags precede starts, 
lower segments precede higher segments (that is, slope is decreasing for terminal flags and increasing for start flags), and red precedes blue.
%pic

An intersection stores the two segments forming it.  \jss{precision}
A \texit{intersection flag} stores the intersection as the flag's point and one of the segments forming the intersection as the flag's segment.  
Even though we refer to them as flags,  intersection flags are generated for output.  They do not need to be compared, which is fortunate, because doing so would require higher precision than we allow.

\subsection{Sweep}\label{sec sweep}
In the double-precision red/blue segment sweep algorithm~\cite{MS}, a flag will \textit{witness} the intersection of segments $s$ and $t$ if it is the smallest flag right of the wedge formed by the intersection of $s$ and $t$.
%pic
In \cite{MS} this algorithm is described as 
treating the $n$ input line segments as monotone curves and pushing all intersections to the right as far as possible -- to their witness flags. 
A line sweeps across the plane, maintaining the order of these curves as alternating bundles of red and blue segments for which all witnessed intersections are to the left and unwitnessed intersections are to the right of the sweepline. 
An event occurs at each flag, which may witness intersections between several bundles, as well as terminating or starting a segment.  
The paper~\cite{MS} shows that bundles can be processed by split, swap, and merge in $O(n\lg n)$ total time, producing a concise description of all $k$ intersections, even if $k=\Theta(n^2)$.

We refine this in (\ref{sec sweep}) to treat bundle swaps as separate events

This can be refined further to treat segment intersections as separate events. 

K., Iacono, and Langermann~\cite{}  point out that the sweep can be understood as sweeping a pseudoline over the plane.  \jss{let's come back to this to show how, because I think it may make it easier to describe the invariant for the triangulation.}

\subsection{Bundlelist}
The sweepline can be split into alternating sections crossed by blue or by red segments only.
Each alternation is represented by a \textit{bundle}, which contains single color segments that are comparable, consecutive, and increasing with respect to aboveness.
The \textit{bundlelist}
 is formed by grouping these segments among these regions.
Each bundle 
%pic
The bundlelist is  a linked list of bundles that supports swap, split, and merge of bundles; it also supports bundle search by using flags.
Swapping bundles can be easily done in a linked list.
The segments of a bundle will be stored in a splay tree for amortized split time of $O(log(n))$ and amortized merge time of $O(log(m*n))$ where $m$, $n$ are total number of segments in the bundle.
We also keep the red bundles in a splay tree ordered by aboveness (no intersection within a color, so ordering is defined) for binary search on the bundlelist with flags.

\subsection{Interior and Exterior Pairs}
Given two flags whose segments are consecutive with respect to aboveness on the sweepline.
They are an interior pair if the top segment bounds below and the bottom bounds above.
They are an exterior pair if the top segment bounds above and the bottom bounds below.
Note that we allow two segments of different colors to from a pair.
%pic

\subsection{Pinch Pairs}
Two flags are a pinch pair if they sharing the same point and their segments are either interior or exterior pairs.
%pic

\subsection{Move Pairs}
A terminal and a start flag are a move pair if they share the same point, and their segments bound the same direction.
%pic

\subsection{Triangulation}
The output of our algorithm can be the list of boundary cycles with their nesting structure, or a triangulation of the interior of the output region, optionally with its nesting structure. For this implementation we focus on the triangulation.
%pic
%with the update algorithm it can only detect inconsistent labeling in the resulting polygon
%segment crossing of same color have to be checked before hand and is no part of the design

%may need a different word from boundary since it may cause confusion with polygon boundary
\subsection{Boundary} \label{sec boundary}
The boundary is a linked list of flags in counter-clockwise order starting from the sentinel flag on the bottom left of the plane.
The points of the flags connected by the links of the boundary indicate a region.
Any portion of the boundary between two start flags of an interior pair satisfy the condition that the left region is triangulated and the the right region is not.
Adding flags whose points already exist in the boundary and removing flags directly adds or removes the flags from the linked list.
For flags with points not already in the boundary we need to advance the boundary.

%doesn't this requires calculating the actual point of intersection?
\subsubsection{Advance the Boundary}
If $s_0$ and $s_1$ are start flags on the boundary describing interior pairs; let the portion of the boundary between and including them be defined by $r_0$, $r_1$, ... , $r_n$.
Let $f$ be a flag between $s_0$ and $s_1$.
If the points of $r_i$, $r_{i+1}$, $f$ describe a clockwise oriented triangle, the triangle is added to the triangulation; this portion will be updated to satisfy the condition stated in (\ref{sec boundary}).
%picture
If $s_0$ and $s_1$ are start flags on the boundary describing exterior pairs and $f$ is a flag between them,
we advance the boundary by adding $f$ as a new node between the nodes of $s_0$ and $s_1$.
We call this process advancing the boundary between by flag $f$.

%is this necessary since it is discussed in the introduction
\subsection{Boolean Operations}
The result of the set operations union, intersection, or difference on the two polygon groups.
%not sure what local means
The operations are local, even for the regularized. 

\subsection{Visible Segments}
If operation is union, a segment that bounds below is visible if the segment directly above it on the sweepline bounds above; a segment that bounds above is visible if the segment directly below it on the sweepline bounds below;
If the operation is intersection, a segment is visible if the segment directly above is of the opposite color and bounds below and the segment directly below is of the opposite color and bounds above.
%need to explain subtract blue
Visible flags are flags containing visible segments, and visible intersections are intersections containing visible segments.

\section{Segment Intersection Algorithm} \label{sec inter}
The input is two groups of segments such that no segments intersect each other within a group and no segment has an endpoint inside another segment.
This algorithm outputs all the intersections in the order they are witnessed by the flags and in order along the segments for each batch witnessed.
As the sweepline sweeps over the segments, we check that the bundlelist bundles are alternating in color and are ordered with respect to aboveness.

Consider the segments directly above and below the current flag. 
If those two ranges given by the two segments in each group do not overlap, it means the flag witnessed intersection(s) and the bundlelist is no longer ordered by aboveness.
The aboveness order and alternating bundle color invariants can be restored by a sequence of split, swap, and/or merge operations on the bundles.
If bundles $B$, $R$ are swapped, every segment from $B$ intersects every segment from $R$.
If $B$ is originally higher, we record the intersections of this swap starting from the lowest segment of $B$ intersecting $R$ from highest to lowest segment in $R$; we go through all the segments in $B$ from low to high.

\section{Pseudoline Sweep} \label{sec sweep}
The triangulation algorithm uses a pseudoline sweep instead of the sweep defined in (\ref{sec sweep}).
The pseudoline moves through one pinch pair or one move pair at each change.
Intersections, grouped by swaps, witnessed by a flag is available for the triangulation algorithm.
For each swap, the we process intersections in the order recorded in (\ref{sec inter}).
Each intersection can be seen as two pinch pairs or two move pairs, and the pseudoline moves through one pair at a time.
We process each swap in the order it appeared, and lastly the flag itself.
We processes flags individually but the pseudoline moves through one pinch pair or move pair at each change.
Note that a pinch pair is consecutive in flag order but a move pair need not be.

\section{Boolean Ooperation Algorithm}
We execute the segment intersection algorithm.
At every flag and every bundle swap we progress the pseudoline sweep and update the triangulation.
Only the visible intersections of bundle swaps and visible flags will form the objects being swept over by the pseudoline.
The pseudoline will modify the boundary and produce the triangulation.
For a pinch pair, the pseudoline will advance the boundary by adding the first flag then add the second flag if it is an interior pair or remove both flags from the boundary if it is an exterior pair.
For a move pair, the pseudoline will advance the boundary by adding the first flag then replace the first flag by the second flag.

\end{document}