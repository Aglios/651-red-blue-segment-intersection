\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\def\jss#1{{\footnotesize [{\bf jss:} #1]}}
\def\sm#1{{\footnotesize [{\bf jss:} #1]}}

\title{Robust Boolean operations}
\author{Shengtan Mao, Jack Snoeyink}
\date{\today}


%pictures: fill in a small corner

\begin{document}

\maketitle
\begin{abstract}
We detail an implementation of regularized Boolean operations (union, intersection, difference) for two polygonal regions in the plane that produces polygons of the resulting region.
The polygons are organized in a tree with respect to their nesting.
It is based on an optimal red/blue segment intersection algorithm that requires only double the input precision.  
We carefully define predicates so that we do not need to define shared endpoints or overlapping segments as degeneracies requiring special handling, but can fold them into the general case.  
%Output can be produced in compact forms.  
We do not address the geometric rounding of intersection points (which may require more than double precision) back to input precision, since such rounding must be application-specific.
\end{abstract}
\section{Introduction}

%% Set context
The Boolean operations of intersection, union, and difference for polygonal regions in the plane are fundamental to applications such as Geographic Information Systems (GIS)
and Computer Aided Design (CAD).  
In these applications the input is one or more collections of straight line segments that bound a region of the plane.
Each segment is labeled with which side is the region interior; our algorithm will detect if the labels are inconsistent.
The desired output may be the union, intersection, difference or symmetric difference of regions. 

Given two polygonal regions, red and blue, we want to explore the resulting region after union, intersection, of subtraction of blue region.
We assume that the input regions are regularized -- that each region equals the closure of its interior, $A= \textit{cl}(\textit{int}(A))$, and produce regularized output of the result after Boolean operation. 
Regularization removes low dimensional features, allowing us to define boundary cycles: we define a region's \textit{boundary} to be the nested set of cycles of segments that share a vertex, forming an angle that is locally entirely inside one region.
Note that this definition is asymmetric in its handling of the interior and exterior of a region:  Two triangles that touch at a single vertex are considered as two separate cycles if the interior is inside, and as a single cycle if the interior is outside.

We expect the input precision 32 bits; this allows 64-bit architectures to perform the algorithm.
Points in the plane are represented by ordered pairs of 32-bit integers.

Sweep algorithms in the plane convert two-dimensional problems into dynamic one-dimensional problems,
often by sweeping a line or pseudoline across segments in the
plane and observing events where the order of segments crossing the sweep changes.
In such a sweep,  the events will be segment endpoints and intersections. 
We want definitions that simplify special cases and allows optimization.
An important special case is when many segments end at a common point, but we want to process them one at a time.
An important optimization to make is on processing segments that cross as a grid.  
Therefore, we begin with several definitions and invariants before we identify the events and explain how to handle them. 

\section{Definitions}
Points in the plane are compared by lexicographic order, breaking ties in $x$ coordinates by comparing $y$ coordinates.

\subsection{Segments, Flags, Intersections}
A \textit{segment} consists of two endpoints $p<q$, a color (red or blue), and
an \textit{orientation}.
If the orientation is positive the segment bounds the region to its left; if the orientation is negative the segment bounds the region to its right;
We assume that segment endpoints are represented exactly in {\it input precision}.
We assume the relative interior of any segment $pr$ does not contain an endpoint $q$ of another segment.
Note the algorithm can process the equivalent formation of $pr$ broken into $pq$ and $qr$.

Because segments can share endpoints, it is useful to introduce \textit{flags}: segment $pq$ has a \textit{start flag} at $p$ and \textit{terminal flag} at $q$, which inherit the color, slope, and label from $pq$. 
To compare flags, we compare the points, breaking ties so terminal flags precede starts, lower segments precede higher segments (that is, slope is decreasing for terminal flags and increasing for start flags), and red precedes blue.
We refer to this as \textit{flag order}.

An \textit{intersection} consists of the two segments, one red and one blue, forming it.
We store the two segments since storing the actual point of intersection requires \sm{more than double} precision
A \texit{intersection flag} consists of the intersection as the flag's point and one of the segments forming the intersection, and an indication of whether the intersection starts or terminates the segment.
Intersections flags that share the same point are compared in the same manner as normal flags.
We do not need to compare intersection flags in any other cases, which means explicit calculation of the intersection point is not needed.


\subsection{Pseudoline Sweep}\label{sec psweep}
In the double-precision red/blue segment sweep algorithm~\cite{MS}, a flag will \textit{witness} the intersection of segments $s$ and $t$ if it is the smallest flag right of the wedge formed by the intersection of $s$ and $t$.
In \cite{MS} this algorithm is described as treating the $n$ input line segments as monotone curves and pushing all intersections to the right as far as possible -- to their witness flags.
A line sweeps across the plane, maintaining the order of these curves as alternating bundles of red and blue segments for which all witnessed intersections are to the left and unwitnessed intersections are to the right of the sweepline. 
An event occurs at each flag, which may witness intersections between several bundles, as well as terminating or starting a segment.  
The paper~\cite{MS} shows that bundles can be processed by split, swap, and merge in $O(n\lg n)$ total time, producing a concise description of all $k$ intersections, even if $k=\Theta(n^2)$.


%partial grid column major
We offer a pseudoline interpretation of the sweepline.
The pseudoline passes through one flag (not intersection flag) or an intersection on each update.
The pseudoline passes through flags in flag order.
A flag $f$ witnessed intersections if the pseudoline cannot move past $f$ and maintain the order the segments intersecting the pseudoline while intersecting no segment twice.
The pseudoline then moves past the witnessed intersections in the order detailed by the algorithm in (\ref{seg inter}).
%pic
This series of pictures demonstrate how the pseudoline moves past six flags sharing the same point.

\subsection{Bundlelist}
The pseudoline can be split into alternating sections crossed by blue or by red segments only.
Each alternation is represented by a \textit{bundle}, which contains single color segments that are comparable, consecutive, and increasing with respect to aboveness.
The \textit{bundlelist} is formed by grouping these segments among these regions; it is a linked list of bundles.
The bundlelist supports swap, split, and merge of bundles.
It also supports bundle search using flags: which finds the red and blue bundle encompassing or directly below the flag.
We refer interested readers to \cite{MS} for more detail and motivation behind the bundlelist.

\subsection{Event Pairs}
Two segments are \textit{comparable} if there exists a state of the sweepline(pseudoline) that intersects both segments.
Note that the order of aboveness of two comparable segments depend on the particular state of the sweepline.
Given two flags whose segments are comparable and consecutive with respect to aboveness on the sweepline.
They are an \textit{interior pair} if the top segment bounds below and the bottom bounds above.
They are an \textit{exterior pair} if the top segment bounds above and the bottom bounds below.
Note that we allow two segments of different colors to from a pair.

Two flags are a \textit{start pair} if they are start flags that share the same point, and the flags' segments are both interior or both exterior pairs.
Two flags are a \textit{terminal pair} if they are terminal flags that share the same point, and the flags' segments are both interior or both exterior pairs.
A terminal and a start flag are a \textit{move pair} if they share the same point, and their segments bound the same direction.
An event pair is any type of pairs above.

%boundary segments
\subsection{Boundary Segments}
If operation is union, a segment that bounds below is visible if the segment directly above it on the sweepline bounds above; a segment that bounds above is visible if the segment directly below it on the sweepline bounds below;
If the operation is intersection, a segment is visible if the segment directly above is of the opposite color and bounds below and the segment directly below is of the opposite color and bounds above.
%need to explain subtract blue
Visible flags are flags containing visible segments, and visible intersections are intersections containing visible segments.

\section{Segment Intersection Algorithm} \label{sec inter}
The input is two groups, red and blue, of segments; we require no segments intersect each other within a group and no segment has an endpoint inside another segment.
This algorithm outputs all the intersections in the order they are passed by the pseudoline.
As the pseudoline sweeps over the segments, we check that the bundlelist bundles are alternating in color and are ordered with respect to aboveness.

Consider the red segments and blue segments directly above and below the current flag $f$. 
If those two ranges given by the two segment pairs do not overlap on the pseudoline, the order the segments intersect the pseudoline will change if the pseudoline moves past $f$, which means the flag witnessed intersection(s).
We start with the bundle, $S$, related to the originally lower pair of segments that give the two ranges; the aboveness order and alternating bundle color invariants can be restored by a sequence of split, swap, and/or merge operations on the bundlelist.
If bundles $B$, $R$ are swapped, every segment from $B$ intersects every segment from $R$.
If $B$ is originally higher, we record the intersections of this swap starting from the lowest segment of $B$ intersecting $R$ from highest to lowest segment in $R$; we go through all the segments in $B$ from low to high.
Lastly we add the flag's segment to the bundlelist for start flags and remove the flag's segment to the bundlelist for terminal flags.
If those two ranges given by the two segment pairs do not overlap on the pseudoline, it means no intersections are witnessed and the bundlelist is no still ordered by aboveness; we directly go to the last step of adding/removing the flag's segment.
We refer interested readers to \cite{MS}.

We can now give full details of the pseudoline sweep in \ref{sec psweep}.
When flag $f$ is a witness, the pseudoline moves past intersections in the order recorded in the previous paragraph.
%pic
This series of pictures shows how the psuedoline moves past the first bundle swap.
%pic
This series of pictures shows how the pseudoline moves past the second bundle swap and the flag $f$.

\section{Boolean Ooperation Algorithm}
\subsection{Pseudoline Sweep} \label{sec psweep2}
We define the \textit{Boolean-pseudoline} (bpline) sweep, which is a modification of the pseudoline sweep in (\ref{sec psweep}).
The bpline moves through one event pair at each update.
Flags are processed in flag order and the bpline moves through an event pair whenever two flags are verified to form one.
We examine intersections in the same order as the pseudoline.
Each intersection has four intersection flags sharing the same point, and the bpline moves through the intersection flags in the same way as normal flags.
Note that a move pair need not be consecutive in flag order; this means we need to store flags that do not immediately form an event pair with another flag.
If a flag does not form an event pair with any other flag, we have observed an inconsistency in the orientation of the input polygons regions and report an error.
%pic
This shows how the pbline moves past a point shared by two blue and two red vertices with intersection as the Boolean operation.

Pbline maintains boundary segments as a linked list of segments and is not a bundlelist because pbline will not observe intersection and do not need to swap the order of any two segments.



%when recording above shoot line to see if intersected above twice
%if it did the recorded as sibling
%if not record it as child


\subsection{Boundary Cycles} \label{sec bcycle}
A polygon $a$ is \textit{above} polygon $b$ if the segment directly above the point of $b$'s terminal flags is a segment that forms the boundary of $a$.
A polygon $b$ is \textit{below} polygon $a$ if $b$ is above $a$.
A polygon $c$ is a \textit{child} of $b$ if $b$ is above $c$ and the winding number of the point of $c$'s terminal flag with respect to $b$ is non-zero.
A polygon $c$ is a \textit{sibling} of $b$ if $b$ is above $c$ and the winding number of the point of $c$'s terminal flag with respect to $b$ is zero; this means 
A \textit{boundary cycle} $B$ contains a polygon $b$, a pointer to the boundary cycle of the polygon above $b$, and a list of boundary cycles of the polygons that are below and children of $b$, and a list of boundary cycles of the polygons that are below and siblings of $b$.
The left side of the oriented segments formed by the $B$'s list is the insde of a polygon.

Each segment needs a pointer to the boundary cycle it contributed to.
When a boundary cycle $B$'s polygon is complete at flag $f$, we can determine if it is a child or sibling of its above boundary cycle $A$ by using the stabbing line.
Starting at $f$ and following the pbline upwards, we count how many times the pbline intersects the polygon of $A$.
If the pbline intersects $A$'s polygon an even number of times, $B$ is a sibling of $A$; if the pbline intersects $A$'s polygon an odd number of times, $B$ is a child of $A$.



\subsection{Algorithm}
We execute the segment intersection algorithm.
Between every flag and every bundle swap we progress the bpline sweep and update the boundary cycles.
The resulting boundary of the Boolean operator forms the objects being swept over by the bpline.
The boundary cycles will be maintained as the bpline is updated.
When the polygon of a boundary cycle $B$ finishes, we looked at set $B$'s pointer to the boundary cycle, $A$, above $B$; we add $B$ to the children below list of $A$.
For a child $C$ below $B$, every boundary cycle in the subtree of $C$ formed with respect to sibling below is a child of $B$.
Doing this for every child of $B$ allows us to construct the tree of polygons with respect to nesting.
We then delete the list of children below of $B$ but keep the list of siblings below since future boundary cycles may need to access it.

\end{document}