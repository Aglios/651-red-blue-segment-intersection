\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\def\jss#1{{\footnotesize [{\bf jss:} #1]}}

\title{Boolean Operations}
\author{Shengtan Mao, Jack Snoeyink}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
We detail an implementation of regularized Boolean operations (union, intersection, difference) for two polygonal regions in the plane that directly produces a triangulation of the output region. 
It is based on an optimal red/blue segment intersection algorithm that requires only double the input precision.  
We carefully define predicates so that we do not need to define shared endpoints or overlapping segments as degeneracies requiring special handling, but can fold them into the general case.  
Output can be produced in compact forms.  
We do not address the geometric rounding of intersection points (which may require more than double precision) back to input precision, since such rounding must be application-specific.
\end{abstract}
\section{Introduction}

%% Set context
The Boolean operations of intersection, union, and difference for polygonal regions in the plane are fundamental to applications such as Geographic Information Systems (GIS)
and Computer Aided Design (CAD).  
In these applications the input is one or more collections of straight line segments that bound a region of the plane.
Each segment is labeled with which side is the region interior; our algorithm will detect if the labels are inconsistent.
The desired output may be the union, intersection, difference or symmetric difference of regions. 

We assume that the input region is regularized -- that it equals the closure of its interior, 
$A= \textit{cl}(\textit{int}(A))$. , and produce regularized output. 
Regularization removes low dimensional features, allowing us to define boundary cycles: 
We define a region's \textit{boundary} to be the nested set of cycles of segments that share a vertex, forming an angle that is locally entirely inside one region.
Note that this definition is asymmetric in its handling of the interior and exterior of a region:  Two triangles that touch at a single vertex are considered as two separate cycles if the interior is inside, and as a single cycle if the interior is outside.  

Input precision

Boolean operations

Sweep algorithms in the plane convert two-dimensional problems into dynamic one-dimensional problems,
often by sweeping a line or pseudoline across segments in the
plane and observing events where the order of segments crossing the sweep changes.
In such a sweep,  the events will obviously be segment endpoints and intersections. Like many obvious things in mathematics it takes careful definition to make this precise -- especially when many segments can end at a common endpoint, but we want to process them one at a time to keep the handling simple, and when we want to process bundles of segments the cross as a grid for efficiency.  
Therefore, we begin with several definitions and invariants before we identify the events and say how to handle them. 

\section{Definitions}
Points in the plane are compared by lexicographic order, breaking ties in $x$ coordinates by comparing $y$ coordinates.

\subsection{Segments, Flags, Intersections}
A \textit{segment} consists of two endpoints $p<q$, a color (red or blue), and
a label whether the region it bounds is above or below. 
%pic
We assume that segment endpoints are represented exactly in {\it input precision}.
If the relative interior of any segment $pr$ contains a segment endpoint $q$, 
then we break $pr$ into $pq$ and $qr$. We cannot break at all intersection points, 
because those may require greater than input precision. 

Because segments can share endpoints, it is useful to introduce \textit{flags}: 
segment $pq$ has a \textit{start} flag at $p$ and \textit{terminal} flag at $q$, 
which inherit the color, slope, and label from $pq$. 
\jss{probably need notation for the flags of $pq$: could even use $p_q$ for start and $_pq$ for terminal.}
%identifying flags in words may be clearer since the flag point could be an intersection
To compare flags, we compare the points, breaking ties so terminal flags precede starts, 
lower segments precede higher segments (that is, slope is decreasing for terminal flags and increasing for start flags), and red precedes blue.
%pic

An intersection stores the two segments forming it.  \jss{precision}
A \texit{intersection flag} stores the intersection as the flag's point and one of the segments forming the intersection as the flag's segment.  
Even though we refer to them as flags,  intersection flags are generated for output.  They do not need to be compared, which is fortunate, because doing so would require higher precision than we allow.

\subsection{Sweep}\label{sec sweep}
In the double-precision red/blue segment sweep algorithm~\cite{MS}, a flag will \textit{witness} the intersection of segments $s$ and $t$ if it is the smallest flag right of the wedge formed by the intersection of $s$ and $t$.
%pic
In \cite{MS} this algorithm is described as 
treating the $n$ input line segments as monotone curves and pushing all intersections to the right as far as possible -- to their witness flags. 
A line sweeps across the plane, maintaining the order of these curves as alternating bundles of red and blue segments for which all witnessed intersections are to the left and unwitnessed intersections are to the right of the sweepline. 
An event occurs at each flag, which may witness intersections between several bundles, as well as terminating or starting a segment.  
The paper~\cite{MS} shows that bundles can be processed by split, swap, and merge in $O(n\lg n)$ total time, producing a concise description of all $k$ intersections, even if $k=\Theta(n^2)$.

We refine this in (\ref{sec pseudo}) to treat bundle swaps as separate events

This can be refined further to treat segment intersections as separate events. 

K., Iacono, and Langermann~\cite{}  point out that the sweep can be understood as sweeping a pseudoline over the plane.  \jss{let's come back to this to show how, because I think it may make it easier to describe the invariant for the triangulation.}
%pseudoline section

\subsection{Bundlelist}
The sweepline can be split into alternating sections crossed by blue or by red segments only.
Each alternation is represented by a \textit{bundle}, which contains single color segments that are comparable, consecutive, and increasing with respect to aboveness.
The \textit{bundlelist}
 is formed by grouping these segments among these regions.
Each bundle 
%pic
The bundlelist is  a linked list of bundles that supports swap, split, and merge of bundles; it also supports bundle search by using flags.
Swapping bundles can be easily done in a linked list.
The segments of a bundle will be stored in a splay tree for amortized split time of $O(log(n))$ and amortized merge time of $O(log(m*n))$ where $m$, $n$ are total number of segments in the bundle.
We also keep the red bundles in a splay tree ordered by aboveness (no intersection within a color, so ordering is defined) for binary search on the bundlelist with flags.

\subsection{Event Pairs}
Two segments are \textit{comparable} if there exists a state of the sweepline(pseudoline) that intersects both segments.
Note that the order of aboveness of two comparable segments depend on the particular state of the sweepline.
Given two flags whose segments are comparable and consecutive with respect to aboveness on the sweepline.
They are an \textit{interior pair} if the top segment bounds below and the bottom bounds above.
They are an \textit{exterior pair} if the top segment bounds above and the bottom bounds below.
Note that we allow two segments of different colors to from a pair.
%pic

Two flags are a \textit{start pair} if they are start flags that share the same point, and the flags' segments are both interior or both exterior pairs.
%pic
Two flags are a \textit{terminal pair} if they are terminal flags that share the same point, and the flags' segments are both interior or both exterior pairs.
A terminal and a start flag are a \textit{move pair} if they share the same point, and their segments bound the same direction.
An event pair is any type of pairs above.
%pic

\subsection{Boundary Cycles}
Our algorithm outputs the list of boundary cycles with their nesting structure.
%pic
%with the update algorithm it can only detect inconsistent labeling in the resulting polygon
%segment crossing of same color have to be checked before hand and is no part of the design

%is this necessary since it is discussed in the introduction
\subsection{Boolean Operations}
The result of the set operations union, intersection, or difference on the two polygon groups.
%not sure what local means
The operations are local, even for the regularized. 

\subsection{Visible Segments}
If operation is union, a segment that bounds below is visible if the segment directly above it on the sweepline bounds above; a segment that bounds above is visible if the segment directly below it on the sweepline bounds below;
If the operation is intersection, a segment is visible if the segment directly above is of the opposite color and bounds below and the segment directly below is of the opposite color and bounds above.
%need to explain subtract blue
Visible flags are flags containing visible segments, and visible intersections are intersections containing visible segments.

\section{Segment Intersection Algorithm} \label{sec inter}
The input is two groups of segments such that no segments intersect each other within a group and no segment has an endpoint inside another segment.
This algorithm outputs all the intersections in the order they are witnessed by the flags and in order along the segments for each batch witnessed.
As the sweepline sweeps over the segments, we check that the bundlelist bundles are alternating in color and are ordered with respect to aboveness.

Consider the segments directly above and below the current flag. 
If those two ranges given by the two segments in each group do not overlap, it means the flag witnessed intersection(s) and the bundlelist is no longer ordered by aboveness.
The aboveness order and alternating bundle color invariants can be restored by a sequence of split, swap, and/or merge operations on the bundles.
If bundles $B$, $R$ are swapped, every segment from $B$ intersects every segment from $R$.
If $B$ is originally higher, we record the intersections of this swap starting from the lowest segment of $B$ intersecting $R$ from highest to lowest segment in $R$; we go through all the segments in $B$ from low to high.

\section{Pseudoline Sweep} \label{sec pseudo}
The triangulation algorithm uses a pseudoline sweep instead of the sweep defined in (\ref{sec sweep}).
The pseudoline moves through one event pair at each change.
Intersections, grouped by swaps, witnessed by a flag is available for the triangulation algorithm.
For each swap, the we process intersections in the order recorded in (\ref{sec inter}).
Each intersection can be seen as two event pairs, and the pseudoline moves through one pair at a time.
We process each swap in the order it appeared, and lastly the flag itself.
We processes flags individually but the pseudoline moves through one event pair at each change.
Note that a move pair need not be consecutive in flag order.

\section{Constructing Boundary Cycles} \label{sec bcycle}
Each \textit{boundary cycle} $b$ is an list of points with a pointer to the boundary cycle $c$ that contains $b$.
The left side of the oriented segments formed by the $b$'s list is the insde of a polygon.
$b$ is contained in $c$ if whenever the pseudoline intersects $b$, the top segment of $b$ is below the top segment of $c$, and the bottom segment of $b$ is above the bottom segment of $c$; and there exist a state of the pseudoline the top segment of $b$ is \textit{directly} below the top segment of $c$, and the bottom segment of $b$ is \textit{directly} above the bottom segment of $c$.

We keep track of all boundary cycles intersecting the pseudoline.
When the pseudoline moves across a start pair, a new boundary cycle is added with a pointer to the boundary cycle containing the segment directly above the start pair.
When the pseudoline moves across a terminal pair, a boundary cycle is finished or two boundary cycles are realized to be one; the pointer will be modified accordingly.
When the pseudoline moves acorss a move pair, an existing boundary cycle gains additional points and its pointer is modified if necessary.
Two boundary cycles may need to be merged, and its pointer may need to point to the containing boundary cycle of the current containing boundary cycle.
Union-find data structure can efficiently store boundary cycles.
Each segment also needs a pointer to the boundary cycle it contributed to.


\section{Boolean Ooperation Algorithm}
We execute the segment intersection algorithm.
Between every flag and every bundle swap we progress the pseudoline sweep and update the boundary cycles.
Only the visible intersections of bundle swaps and visible flags will form the objects being swept over by the pseudoline.
The boundary cycles will be updated with the visible flags, and finished boundary cycles will be recorded.

\end{document}