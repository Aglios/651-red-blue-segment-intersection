\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\def\jss#1{{\footnotesize [{\bf jss:} #1]}}
\def\sm#1{{\footnotesize [{\bf jss:} #1]}}

\title{Robust Boolean operations}
\author{Shengtan Mao, Jack Snoeyink}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
We detail an implementation of regularized Boolean operations (union, intersection, difference) for two polygonal regions in the plane that directly produces a \sm{triangulation} of the output region. 
It is based on an optimal red/blue segment intersection algorithm that requires only double the input precision.  
We carefully define predicates so that we do not need to define shared endpoints or overlapping segments as degeneracies requiring special handling, but can fold them into the general case.  
%Output can be produced in compact forms.  
We do not address the geometric rounding of intersection points (which may require more than double precision) back to input precision, since such rounding must be application-specific.
\end{abstract}
\section{Introduction}

%% Set context
The Boolean operations of intersection, union, and difference for polygonal regions in the plane are fundamental to applications such as Geographic Information Systems (GIS)
and Computer Aided Design (CAD).  
In these applications the input is one or more collections of straight line segments that bound a region of the plane.
Each segment is labeled with which side is the region interior; our algorithm will detect if the labels are inconsistent.
The desired output may be the union, intersection, difference or symmetric difference of regions. 

Given two polygonal regions, red and blue, we want to explore the resulting region after union, intersection, of subtraction of blue region.
We assume that the input regions are regularized -- that each region equals the closure of its interior, $A= \textit{cl}(\textit{int}(A))$, and produce regularized output of the result after Boolean operation. 
Regularization removes low dimensional features, allowing us to define boundary cycles: we define a region's \textit{boundary} to be the nested set of cycles of segments that share a vertex, forming an angle that is locally entirely inside one region.
Note that this definition is asymmetric in its handling of the interior and exterior of a region:  Two triangles that touch at a single vertex are considered as two separate cycles if the interior is inside, and as a single cycle if the interior is outside.

We expect the input precision 32 bits; this allows 64-bit architectures to perform the algorithm.
Points in the plane are represented by ordered pairs of 32-bit integers.

Sweep algorithms in the plane convert two-dimensional problems into dynamic one-dimensional problems,
often by sweeping a line or pseudoline across segments in the
plane and observing events where the order of segments crossing the sweep changes.
In such a sweep,  the events will be segment endpoints and intersections. 
We want definitions that simplify special cases and allows optimization.
An important special case is when many segments end at a common point, but we want to process them one at a time.
An important optimization to make is on processing segments that cross as a grid.  
Therefore, we begin with several definitions and invariants before we identify the events and explain how to handle them. 

\section{Definitions}
Points in the plane are compared by lexicographic order, breaking ties in $x$ coordinates by comparing $y$ coordinates.

\subsection{Segments, Flags, Intersections}
A \textit{segment} consists of two endpoints $p<q$, a color (red or blue), and
an \textit{orientation}.
If the orientation is positive the segment bounds the region to its left; if the orientation is negative the segment bounds the region to its right;
We assume that segment endpoints are represented exactly in {\it input precision}.
We assume the relative interior of any segment $pr$ does not contain an endpoint $q$ of another segment.
Note the algorithm can process the equivalent formation of $pr$ broken into $pq$ and $qr$.

Because segments can share endpoints, it is useful to introduce \textit{flags}: segment $pq$ has a \textit{start flag} at $p$ and \textit{terminal flag} at $q$, which inherit the color, slope, and label from $pq$. 
To compare flags, we compare the points, breaking ties so terminal flags precede starts, lower segments precede higher segments (that is, slope is decreasing for terminal flags and increasing for start flags), and red precedes blue.
We refer to this as \textit{flag order}.
%pic

An \textit{intersection} consists of the two segments, one red and one blue, forming it.
We store the two segments since storing the actual point of intersection requires \sm{more than double} precision
A \texit{intersection flag} consists of the intersection as the flag's point and one of the segments forming the intersection, and an indication of whether the intersection starts or terminates the segment.
Intersections flags that share the same point are compared in the same manner as normal flags.
We do not need to compare intersection flags in any other cases, which means explicit calculation of the intersection point is not needed/


\subsection{Pseudoline Sweep}\label{{sec psweep}}
In the double-precision red/blue segment sweep algorithm~\cite{MS}, a flag will \textit{witness} the intersection of segments $s$ and $t$ if it is the smallest flag right of the wedge formed by the intersection of $s$ and $t$.
%pic
In \cite{MS} this algorithm is described as treating the $n$ input line segments as monotone curves and pushing all intersections to the right as far as possible -- to their witness flags.
A line sweeps across the plane, maintaining the order of these curves as alternating bundles of red and blue segments for which all witnessed intersections are to the left and unwitnessed intersections are to the right of the sweepline. 
An event occurs at each flag, which may witness intersections between several bundles, as well as terminating or starting a segment.  
The paper~\cite{MS} shows that bundles can be processed by split, swap, and merge in $O(n\lg n)$ total time, producing a concise description of all $k$ intersections, even if $k=\Theta(n^2)$.

We offer a pseudoline interpretation of the sweepline.
The pseudoline passes through one flag (not intersection flag) or an intersection on each update.
The pseudoline passes through flags in flag order.
If a flag witnessed intersections, the intersections must be passed through first.
The segments of the intersections form grids, and we can group the intersections by the grid they are in.
The pseudoline passes through grids from low to high; for each grid the pseudoline passes through intersections in order from low to high then left to right.
Finally the pseudoline passes through the flag witnessing these intersections.
%pic

\subsection{Bundlelist}
The pseudoline can be split into alternating sections crossed by blue or by red segments only.
Each alternation is represented by a \textit{bundle}, which contains single color segments that are comparable, consecutive, and increasing with respect to aboveness.
The \textit{bundlelist} is formed by grouping these segments among these regions; it is a linked list of bundles.
%pic
The bundlelist supports swap, split, and merge of bundles.
It also supports bundle search using flags: which finds the red and blue bundle encompassing or directly below the flag.
We refer interested readers to \cite{MS} for more detail and motivation behind the bundlelist.

\subsection{Event Pairs}
Two segments are \textit{comparable} if there exists a state of the sweepline(pseudoline) that intersects both segments.
Note that the order of aboveness of two comparable segments depend on the particular state of the sweepline.
Given two flags whose segments are comparable and consecutive with respect to aboveness on the sweepline.
They are an \textit{interior pair} if the top segment bounds below and the bottom bounds above.
They are an \textit{exterior pair} if the top segment bounds above and the bottom bounds below.
Note that we allow two segments of different colors to from a pair.
%pic

Two flags are a \textit{start pair} if they are start flags that share the same point, and the flags' segments are both interior or both exterior pairs.
Two flags are a \textit{terminal pair} if they are terminal flags that share the same point, and the flags' segments are both interior or both exterior pairs.
%pic
A terminal and a start flag are a \textit{move pair} if they share the same point, and their segments bound the same direction.
%pic
An event pair is any type of pairs above.

\subsection{Visible Segments}
If operation is union, a segment that bounds below is visible if the segment directly above it on the sweepline bounds above; a segment that bounds above is visible if the segment directly below it on the sweepline bounds below;
If the operation is intersection, a segment is visible if the segment directly above is of the opposite color and bounds below and the segment directly below is of the opposite color and bounds above.
%need to explain subtract blue
Visible flags are flags containing visible segments, and visible intersections are intersections containing visible segments.

\section{Segment Intersection Algorithm} \label{sec inter}
The input is two groups, red and blue, of segments; we require no segments intersect each other within a group and no segment has an endpoint inside another segment.
This algorithm outputs all the intersections in the order they are passed by the pseudoline.
As the pseudoline sweeps over the segments, we check that the bundlelist bundles are alternating in color and are ordered with respect to aboveness.

Consider the red segments and blue segments directly above and below the current flag. 
If those two ranges given by the two segment pairs do not overlap on the pseudoline, it means the flag witnessed intersection(s) and the bundlelist is no longer ordered by aboveness.
We start with the bundle, $S$, related to the originally lower pair of segments; the aboveness order and alternating bundle color invariants can be restored by a sequence of split, swap, and/or merge operations on the bundlelist.
If bundles $B$, $R$ are swapped, every segment from $B$ intersects every segment from $R$; this forms the grid arrangement mentioned in \ref{sec psweep}
If $B$ is originally higher, we record the intersections of this swap starting from the lowest segment of $B$ intersecting $R$ from lowest to highest  segment in $R$; we go through all the segments in $B$ from low to high.
Lastly we add the flag's segment to the bundlelist for start flags and remove the flag's segment to the bundlelist for terminal flags.
If those two ranges given by the two segment pairs do not overlap on the pseudoline, it means no intersections are witnessed and the bundlelist is no still ordered by aboveness; we directly go to the last step of adding/removing the flag's segment.
We refer interested readers to \cite{MS}; the important note is that the order the interesctions are reported and the order the flags are processed together are consistent with the order the pseudoline sweeps through intersections and flags.

\section{Pseudoline Sweep} \label{sec psweep2}
We define the \textit{Boolean-pseudoline} (bpline) sweep, which is a modification of the pseudoline sweep in (\ref{{sec psweep}).
The bpline moves through one event pair at each update.
Flags are processed in flag order and the bpline moves through an event pair whenever the flags form an event pair.
We examine intersections in the same order as the pseudoline.
Each intersection has four intersection flags sharing the same point, so the bpline moves through the intersection flags in the same way as normal flags.
Note that a move pair need not be consecutive in flag order; this means we need to temporarily store flags that do not immediately form an event pair with another flag.
If a flag does not form an event pair with any other flag, we have observed an inconsistency in the orientation of the input polygons regions.

\section{Constructing Boundary Cycles} \label{sec bcycle}
Each \textit{boundary cycle} $b$ is an list of points with a pointer to the boundary cycle $c$ that contains $b$.
The left side of the oriented segments formed by the $b$'s list is the insde of a polygon.
$b$ is contained in $c$ if whenever the pseudoline intersects $b$, the top segment of $b$ is below the top segment of $c$, and the bottom segment of $b$ is above the bottom segment of $c$; and there exist a state of the pseudoline the top segment of $b$ is \textit{directly} below the top segment of $c$, and the bottom segment of $b$ is \textit{directly} above the bottom segment of $c$.

We keep track of all boundary cycles intersecting the pseudoline.
When the pseudoline moves across a start pair, a new boundary cycle is added with a pointer to the boundary cycle containing the segment directly above the start pair.
When the pseudoline moves across a terminal pair, a boundary cycle is finished or two boundary cycles are realized to be one; the pointer will be modified accordingly.
When the pseudoline moves acorss a move pair, an existing boundary cycle gains additional points and its pointer is modified if necessary.
Two boundary cycles may need to be merged, and its pointer may need to point to the containing boundary cycle of the current containing boundary cycle.
Union-find data structure can efficiently store boundary cycles.
Each segment also needs a pointer to the boundary cycle it contributed to.


\section{Boolean Ooperation Algorithm}
We execute the segment intersection algorithm.
Between every flag and every bundle swap we progress the bpline sweep and update the boundary cycles.
Only the visible intersections of bundle swaps and visible flags will form the objects being swept over by the bpline.
The boundary cycles will be updated with the visible flags, and finished boundary cycles will be recorded.
\end{document}